# Axon Project - Copilot Instructions

## Project Overview

Axon is a scalable context management architecture for intelligent copilot systems. It's a middleware-based system that intercepts user prompts, enriches them with relevant context from a multi-tier context base, and synthesizes contextually-aware responses through LLM integration.

## Architecture Principles

### System Architecture

- **Middleware-based architecture** with 5 primary layers:
  1. User Interface Layer
  2. Middleware Layer (Prompt Collector → Analyzer → CREE → Synthesizer → Injector)
  3. Context Management Layer (3-tier: Workspace → Hybrid → Global)
  4. LLM Interface Layer
  5. Response Post-Processor

### Core Components

- **Prompt Collector**: Captures user interactions and metadata
- **Prompt Analyzer**: Multi-stage analysis (Intent → Task Type → Entity Extraction → Ambiguity Detection)
- **CREE (Context Retrieval and Evolution Engine)**: Core context management with hierarchical retrieval, semantic search, and evolution mechanisms
- **Context Synthesizer**: Transforms retrieved context with prioritization, compression, and token budget management
- **Injector**: Constructs enriched prompts with multiple injection strategies
- **Response Post-Processor**: Quality assessment, action extraction, and context feedback loop

## Technology Stack

### Monorepo Structure

- **Build Tool**: Turbo for efficient monorepo management and caching
- **Package Manager**: pnpm for fast, disk-efficient dependency management
- **Structure**:
  - `/packages/{middleware, context-engine, prompt-analyzer, llm-gateway, quality-gate, workspace-manager, shared, cli}`
  - `/apps/{api, web}`
  - `/docs`, `/scripts`, `/docker`

### Microservices Architecture

Each package in `/packages` is a **distinct microservice** with:

- Independent scaling capabilities
- Clear service boundaries
- Own test suite and dependencies
- Single responsibility principle

**Core Services**:

1. **middleware**: Orchestration service - coordinates all other services
2. **context-engine**: Context retrieval, storage, and evolution
3. **prompt-analyzer**: Intent classification and entity extraction
4. **llm-gateway**: Abstraction layer for multiple LLM providers
5. **quality-gate**: Testing, linting, and validation orchestration
6. **workspace-manager**: Workspace-specific context management
7. **shared**: Common types, utilities, and configurations

### Backend (TypeScript/Node.js)

- **Framework**: Express.js with TypeScript
- **Language**: TypeScript for type safety and maintainability
- **API Layer**: RESTful APIs with Server-Sent Events (SSE) for streaming
- **Inter-Service Communication**: Direct imports (monorepo), future: gRPC/REST
- **Microservices Pattern**: Each service is independently deployable

### Python Microservices (Optional for MVP)

- **Framework**: FastAPI for Python services
- **Use Cases**:
  - Advanced ML-based prompt classification (post-MVP)
  - Custom embedding generation (if needed)
  - Complex NLP tasks requiring Python libraries
- **Integration**: REST APIs or message queues for communication

### Storage Layer

- **Vector Database**: Pinecone (managed) or Qdrant (self-hosted) for semantic search
- **Document Store**: MongoDB for context metadata, workspaces, and interactions
- **Cache Layer**: Redis for frequent context access and lightweight message queue
- **Graph Database**: Neo4j (deferred to post-MVP for relationship management)

### Message Queue

- **Primary**: BullMQ (Redis-based) for async job processing
- **Use Cases**: Context evolution, quality gate execution, batch operations
- **Future**: RabbitMQ/Kafka for more complex event-driven architecture

### LLM Integration

- **Primary**: OpenAI API (GPT-4)
- **Secondary**: Anthropic Claude
- **Future**: Local models (Llama) support

## Development Standards

### Code Quality

- **Linting**: ESLint with strict TypeScript rules
- **Formatting**: Prettier for consistent code style
- **Type Safety**: Strict TypeScript configuration, no `any` types without justification
- **Error Handling**: Comprehensive try-catch blocks, proper error propagation
- **Logging**: Structured logging with appropriate log levels

### Testing Strategy

- **Unit Tests**: Jest for all business logic
- **Integration Tests**: Test service interactions and API endpoints
- **E2E Tests**: Playwright for end-to-end workflows
- **Coverage**: Minimum 80% code coverage for critical paths
- **Test Structure**: Co-located with source files or in `__tests__` directories

### Architecture Patterns

- **Separation of Concerns**: Clear boundaries between layers and components
- **Dependency Injection**: Use DI for testability and flexibility
- **Repository Pattern**: Abstract data access logic
- **Service Layer**: Business logic isolated from controllers
- **Event-Driven**: Use events for cross-service communication
- **SOLID Principles**: Follow SOLID for maintainable code

### API Design

- **RESTful Conventions**: Proper HTTP methods and status codes
- **Versioning**: API versioning strategy (e.g., `/api/v1/`)
- **Error Responses**: Consistent error response format
- **Request Validation**: Validate all inputs with schemas (Zod/Joi)
- **Rate Limiting**: Implement rate limiting for API endpoints
- **Authentication**: JWT-based authentication with refresh tokens

### Documentation

- **Code Comments**: JSDoc/TSDoc for public APIs and complex logic
- **README Files**: Each package has comprehensive README
- **API Documentation**: OpenAPI/Swagger specifications
- **Architecture Docs**: Keep `/docs` updated with architectural decisions
- **Inline Documentation**: Explain "why" not just "what"

### Git Workflow

- **Commit Messages**: Follow conventional commits (feat:, fix:, docs:, refactor:, test:, chore:)
- **Branch Strategy**: Feature branches from main, PR-based workflow
- **Code Reviews**: All changes require review before merge
- **CI/CD**: Automated testing and linting on PR

## Workspace Types

### Coding Workspace

- Focus on software development workflows
- Context includes: project structure, tech stack, conventions, architecture
- Task types: general query, bug fix, documentation, feature add/remove, refactor, code review, testing, deployment, roadmaps, security, optimization

### PKM (Personal Knowledge Management) Workspace

- Focus on knowledge management and note-taking
- Context includes: note graph, content, workflow patterns
- Task types: note operations, reference management, project management, templating, visualizations, automation, research

### Root Workspace

- Meta-workspace for cross-domain tasks
- Global preferences and configurations
- Cross-workspace knowledge synthesis

## Context Management Principles

### Context Tiers

1. **Workspace Context** (Highest Priority): Project-specific information
2. **Hybrid Context Bridge** (Medium Priority): Runtime integration of workspace + global
3. **Global Context** (Fallback): Cross-workspace knowledge and user preferences

### Context Retrieval

- **Hierarchical**: Search in priority order (Workspace → Hybrid → Global)
- **Semantic**: Vector embeddings for similarity-based retrieval
- **Graph-Based**: Follow relationship links (dependencies, concepts, temporal)
- **Rule-Based**: Task-type specific filtering

### Context Evolution

- Feedback integration from user corrections
- Usage pattern learning
- Temporal decay for outdated context
- Automatic summarization
- Conflict resolution

### Token Budget Management

- Prioritize context by relevance and task type
- Apply compression when needed
- Reserve tokens for response generation
- Dynamic allocation based on prompt complexity

## Quality Assurance

### Pre-Commit Checks

- Linting passes (ESLint)
- Formatting passes (Prettier)
- Type checking passes (TypeScript)
- Unit tests pass

### Post-Development Verification

- No compilation errors
- No runtime errors
- Unit tests pass for modified units
- Integration tests verify inter-service functionality
- Documentation reflects changes
- Security best practices followed

### Code Review Checklist

- Follows architecture principles
- Proper error handling
- Adequate test coverage
- Documentation updated
- No security vulnerabilities
- Performance considerations addressed

## Security Best Practices

- **Input Validation**: Sanitize all user inputs
- **Authentication**: Secure JWT implementation
- **Authorization**: Role-based access control
- **Data Encryption**: Encrypt sensitive data at rest and in transit
- **API Security**: CORS, rate limiting, API key management
- **Dependency Security**: Regular security audits (npm audit, Snyk)
- **Environment Variables**: Never commit secrets, use .env files
- **SQL Injection**: Use parameterized queries (even for NoSQL)

## Performance Optimization

- **Caching**: Redis for frequent context access, LRU eviction
- **Lazy Loading**: Load non-essential context on-demand
- **Parallel Retrieval**: Fetch from multiple context sources concurrently
- **Database Indexing**: Proper indexes on frequently queried fields
- **Connection Pooling**: Reuse database connections
- **Async Operations**: Non-blocking I/O for all external calls
- **Pagination**: Implement pagination for large datasets

## Scalability Considerations

- **Stateless Services**: Enable horizontal scaling
- **Distributed Databases**: Shard context storage by workspace
- **Load Balancing**: Prepare for multi-instance deployment
- **Microservices**: Independent scaling of components
- **Message Queues**: Decouple services for better scaling
- **Monitoring**: Prometheus + Grafana for performance tracking

## File Structure Conventions

```
axon/
├── packages/                    # Microservices packages
│   ├── middleware/              # Core orchestration service
│   │   ├── src/
│   │   │   ├── services/       # Orchestrator, collectors, synthesizers
│   │   │   ├── api/            # Express routes
│   │   │   ├── models/         # Data models
│   │   │   ├── utils/          # Utilities
│   │   │   └── index.ts
│   │   ├── tests/
│   │   │   ├── unit/
│   │   │   └── integration/
│   │   └── package.json
│   │
│   ├── context-engine/          # Context management service
│   │   ├── src/
│   │   │   ├── retrieval/      # Context retrieval logic
│   │   │   ├── evolution/      # Context evolution engine
│   │   │   ├── storage/        # Storage adapters (Vector, Document)
│   │   │   ├── graph/          # Graph operations (future)
│   │   │   ├── services/       # Embedding, caching services
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── prompt-analyzer/         # Prompt analysis service
│   │   ├── src/
│   │   │   ├── classifiers/    # Intent & task classifiers
│   │   │   ├── extractors/     # Entity extractors
│   │   │   ├── models/         # ML model wrappers
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── llm-gateway/             # LLM interface abstraction
│   │   ├── src/
│   │   │   ├── providers/      # OpenAI, Anthropic, Ollama
│   │   │   ├── streaming/      # Streaming support
│   │   │   ├── retry/          # Retry logic & circuit breakers
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── quality-gate/            # Quality assurance service
│   │   ├── src/
│   │   │   ├── testing/        # Test execution
│   │   │   ├── linting/        # Lint checks
│   │   │   ├── validation/     # Validation logic
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── workspace-manager/       # Workspace context management
│   │   ├── src/
│   │   │   ├── coding/         # Coding workspace handler
│   │   │   ├── pkm/            # PKM workspace handler
│   │   │   ├── root/           # Root workspace handler
│   │   │   ├── extractors/     # Context extractors
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── shared/                  # Shared types and utilities
│   │   ├── src/
│   │   │   ├── types/          # TypeScript interfaces
│   │   │   ├── utils/          # Common utilities
│   │   │   ├── constants/      # Constants
│   │   │   ├── config/         # Config schemas
│   │   │   └── index.ts
│   │   └── package.json
│   │
│   └── cli/                     # CLI tool (future)
│       ├── src/
│       └── package.json
│
├── apps/                        # Application entry points
│   ├── api/                     # Main API gateway
│   │   ├── src/
│   │   │   ├── routes/         # API routes
│   │   │   ├── middleware/     # Express middleware
│   │   │   ├── websocket/      # WebSocket support (future)
│   │   │   └── server.ts       # Express server
│   │   ├── tests/
│   │   └── package.json
│   │
│   └── web/                     # Web UI (future)
│       └── package.json
│
├── docs/                        # Documentation
│   ├── architecture/            # Architecture docs
│   ├── api/                     # API specifications
│   └── guides/                  # User guides
│
├── scripts/                     # Build and utility scripts
├── docker/                      # Docker configurations
├── .github/                     # GitHub Actions
├── turbo.json                   # Turbo configuration
├── pnpm-workspace.yaml          # pnpm workspace config
├── package.json                 # Root package.json
├── tsconfig.base.json           # Base TypeScript config
└── README.md
```

## Naming Conventions

- **Files**: kebab-case (e.g., `prompt-analyzer.ts`)
- **Directories**: kebab-case (e.g., `context-management`)
- **Classes**: PascalCase (e.g., `PromptAnalyzer`)
- **Functions/Variables**: camelCase (e.g., `analyzePrompt`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_TOKEN_LIMIT`)
- **Interfaces**: PascalCase with `I` prefix or descriptive name (e.g., `IPromptAnalyzer` or `PromptAnalyzerConfig`)
- **Types**: PascalCase (e.g., `PromptType`, `TaskCategory`)
- **Enums**: PascalCase with singular name (e.g., `TaskType`, `ContextTier`)

## Environment-Specific Guidelines

- **Development**: Verbose logging, hot reload, relaxed CORS
- **Staging**: Production-like, with test data, monitoring enabled
- **Production**: Minimal logging, strict security, performance optimized

## AI Agent Instructions

When generating code or making suggestions:

1. **Always consider the full architecture** - Understand which layer/component you're working on
2. **Follow the tech stack** - Use TypeScript for API/orchestration, Python for ML/NLP tasks
3. **Implement proper error handling** - Try-catch blocks, error propagation, logging
4. **Write tests** - Unit tests for new functions, integration tests for services
5. **Document your code** - JSDoc for public APIs, comments for complex logic
6. **Follow naming conventions** - Be consistent with the project style
7. **Consider scalability** - Write stateless, horizontally scalable code
8. **Security first** - Validate inputs, handle authentication, protect sensitive data
9. **Performance matters** - Use caching, async operations, efficient algorithms
10. **Separation of concerns** - Keep components focused and independent
11. **Update documentation** - Reflect changes in README or relevant docs
12. **Quality gates** - Ensure linting, formatting, type-checking pass

## MVP Scope Priorities

### Phase 1 (Current MVP)

- Core middleware layer (Prompt Collector, Analyzer, basic CREE, Synthesizer, Injector)
- Simple context base (workspace tier with MongoDB)
- Basic vector search (Pinecone)
- OpenAI integration
- Single workspace type (Coding)
- Essential task types (general query, bug fix, feature addition)

### Phase 2 (Post-MVP)

- Full context evolution engine
- Hybrid context bridge
- Graph database integration (Neo4j)
- Multiple workspace types (PKM, Root)
- Advanced prompt analysis (ML-based)
- Comprehensive testing framework

### Phase 3 (Future)

- Multi-user support
- Real-time collaboration
- Advanced context evolution with RL
- Multi-modal context
- Domain-specific optimizations

## Common Pitfalls to Avoid

- ❌ Skipping error handling for "simple" operations
- ❌ Hardcoding configuration values
- ❌ Ignoring token budget constraints
- ❌ Over-fetching context (performance impact)
- ❌ Under-fetching context (quality impact)
- ❌ Not validating external inputs
- ❌ Mixing business logic with controllers
- ❌ Forgetting to update tests when changing logic
- ❌ Not considering edge cases
- ❌ Premature optimization

## Success Criteria

✅ Code is type-safe and linted
✅ Tests pass and coverage is adequate
✅ Documentation is updated
✅ Performance is acceptable (see benchmarks in research paper)
✅ Security best practices are followed
✅ Code is maintainable and follows SOLID principles
✅ Context injection improves response quality
✅ System is scalable and production-ready

---

**Remember**: Axon is about building intelligent, context-aware AI assistance. Every component should contribute to better understanding and serving user intent through sophisticated context management.
